1- User     - Admin et Technicien
    - id
    - name
    - lastname
    - email
    - password
	-createdAt

2- Ticket
    - name 
    - description
    - categories
	-created At
	-update At
	-priority (agregue una constraint para que sea entre 1 y 3)

    
3- Category
    - name 
    - XXXXdescriptionNO
    - tickets
	
	
	Equipamientos?
	
	
	
	Symfony relations - Mapping the ManyToOne Relationship
	https://symfony.com/doc/7.1/doctrine/associations.html
	
	cada category puede estar asociada a many tickets. Pero cada ticket solo puede estar asociado a una sola category. 
	En resumen:many tickets to one category (or equivalently, one category to many tickets).
	
	
	En la aplicacion el cliente contacta por telefono con soporte y soporte crea el ticket y lo asigna a un tecnico. 
	Hay un rol de administrador y un rol de tecnico con el crud el admin podra asignar un ticket a un tecnico
	

	Etapas para crear entity
	comandos:
	
	php bin/console make:entity
	
	make a migration:
	
	php bin/console make:migration
	php bin/console doctrine:migrations:migrate

	Validation de données
	https://symfony.com/doc/current/validation.html

	Constraints
	En mi entidad categoria pondre una constraints de que el campo no puede estar vacio
	#[Assert\NotBlank]
	
	
	CRUD Category
	php bin/console make:controller CategoryController
	
	apres le crud j'ai installer le paginator
	categoryController on a fait une injection de dependences avec Ingredient repository( sert a recuperer les donnes de la bd)
	CategoryController (instale una extension en vscode PHP DOCBloquer
	
	<?php

namespace App\Controller;

use App\Repository\CategoryRepository;
use Knp\Component\Pager\PaginatorInterface;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;

class CategoryController extends AbstractController
{
    /**
     * Undocumented function
     *
     * @param CategoryRepository $categoryRepository
     * @param PaginatorInterface $paginator
     * @param Request $request
     * @return Response
     */
    #[Route('/category', name: 'app_category', methods:['GET'])]
    public function index(CategoryRepository $categoryRepository, PaginatorInterface $paginator, Request $request): Response
    {

        $categories = $paginator->paginate(
            $categoryRepository->findAll(),
            $request->query->getInt('page', 1), /*page number*/
            10 /*limit per page*/
        );

        //dd($categories); pour voir les donnees
        return $this->render('category/index.html.twig', [
            'categories' => $categories
        ]);
    }
}

apres une condition pour dire sil n'a pas de categories

**********
Creation formulaire pour notre crud Category
Symfony recommande de mettre le moins de logique possible dans les contrôleurs.
C'est pourquoi il est préférable de déplacer les formulaires complexes vers des classes dédiées plutôt que de les définir 
dans les actions du contrôleur. De plus, les formulaires définis dans les classes peuvent être réutilisés dans plusieurs actions et services.

Processing le formulaire

CRUD category ok

************

Entity Ticket

Cuando se actualiza una entidad
comandos:
php bin/console doctrine:migrations:diff

php bin/console cache:clear

Creation crud para Ticket
new ticketedit Ticket controller
-creation de formulario
	php bin/console make:form

COn esto se crea el archivo TicketTyoe, ligado a la entidad Ticket

-Para que el formulario de ticket afiche la parte de categoria que viene de de la entidad categoria se tiene que ir a a la entidad Categoria y agregar la funcion _toString


siguiendo con la categoria en TicketType documentation
https://symfony.com/doc/6.4/reference/forms/types/entity.html#ref-form-entity-query-builder

appel a l'entity Category (EntityType) pour recuperer les donnes avec une query 




    public function add_category(Request $request, EntityManagerInterface $em) : Response
    {

        $form=$this->createForm(CategoryType::class);
        $form->handleRequest($request);

        if($form->isSubmitted()){

            $category=new Category;
            $em->persist($category);
            $em->flush();
            dump($request);

        }
        $formView=$form->createView();

        return $this->render('admin/category/add_category.html.twig', [
            'formView'=>$formView,

        ]);
    }
	
	
	
	
 // $ticket = $form->getData();


TODO!!!!!!!!!!!!!!
Function edit NO FUNCIONA 
    #[Route('/ticket/edition/{id}', name: 'app_ticket_edit', methods: ['GET', 'POST'])]
    public function edit(
        TicketRepository $ticketRepository, 
        int $id, 
        Request $request, 
        EntityManagerInterface $manager): Response
    {
        $ticket = $ticketRepository->findOneBy(["id" => $id]);

        $form = $this->createForm(TicketType::class, $ticket);
        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {

           

            $manager->persist($ticket);
            $manager->flush();
            $this->addFlash(
                'success',
                'Votre ticket a été modifié avec succès !'
            );

            return $this->redirectToRoute('app_ticket');
        }

        return $this->render('ticket/edit.html.twig', [
            'form' => $form->createView()
        ]);
    }
	
	En la funcion delete  agregar un modal que diga está seguro que desea eliminar el ticket
	
	*******
	La securité en symfony ce gere avec le Bundle Security (moi je deja installe ca avec la app). Les autorisations dans Symfony sont toujours liées à un objet utilisateur. 
	Si vous devez sécuriser (des parties de) votre application, vous devez créer une classe d'utilisateurs. 
	Il s'agit d'une classe qui implémente UserInterface . Il s'agit souvent d'une entité Doctrine, mais vous pouvez également utiliser une classe d'utilisateurs dédiée à la sécurité.
		ToDo:
		-Securité et compte utilisateur
		php bin/console make:user
		
		En la entidad User:
		On a cree en User une var $plainPassword.
		apres:     
		public function __construct()
			{
        $this->createdAt = new \DateTimeImmutable();
			}
		La classe \DateTimeImmutable() fait partie de l'extension DateTime de PHP et est utilisée pour créer des objets de date et d'heure immuables (non modifiables).
		
		----
		
		
		-Entity User 
		
		*** Quizas hacer fixtures por aprender y rellenar la base de datos ???? Fixture User Video 10 min 13:05 https://www.youtube.com/watch?v=dODeLDHSnlQ&list=PLUiuGjup8Vg5IGd199d_wvs-Dn8uepCcA&index=10
		***
		
		-Mise en place de fixtures pour tester la aplication composer require --dev orm-fixtures
		Despues instale faker php libreria que genera falsos datos https://fakerphp.github.io/
		comandos:php bin/console d:fixtures:load
		
		Para mejorar el hasheado del password voy a usar Entity Listeners
		Entity listeners that are services must be registered with the entity listener resolver. On top of the annotation in the entity class, 
		you have to tag the service with doctrine.orm.entity_listener for it to be automatically added to the resolver. 
		Use the (optional) entity_manager attribute to specify which entity manager it should be registered with.
		
		Primer codigo para crear usuarios en AppFixtures:
		
		        //Users 
        for ($i = 0; $i <10 ; $i++){
            $user = new User();
            $user->setName($this->faker->firstName())
                 ->setLastname($this->faker->lastName())
                ->setEmail($this->faker->email())
                ->setRoles(['ROLE_USER']);
            //hashed le password
            $hashPasword = $this->passwordHasher->hashPassword(
                $user,
                'password'
            );

            $user->setPassword($hashPasword);

            $manager->persist($user);
        }
		
		Para crear un nuevo servicio en config->services.yaml
		    App\EntityListener\:
			resource: '../src/EntityListener/'
			tags:['doctrine.orm.entity_listener']
			
		Y en la entidad user tambien tuve que hacer cambios
		***OJO***
		en services.yaml, hay que tener cuidado con la indentacion, si no estan al mismo nivel da error
		
		https://symfony.com/bundles/DoctrineBundle/current/entity-listeners.html
		
		
		
		-Validation avec les assert
		-Encodage mot de passe
		-creation formulaire de connexion
	creation formulaire inscription???
	Modification profil utilisateur
	modification mot de passe
	